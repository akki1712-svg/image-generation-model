import os
import base64
from io import BytesIO
from dotenv import load_dotenv
from PIL import Image
import cv2
import gdown
from insightface.app import FaceAnalysis
from insightface.model_zoo import get_model
from gfpgan import GFPGANer
from realesrgan import RealESRGANer
from basicsr.archs.rrdbnet_arch import RRDBNet
import google.genai as genai
from google.genai import types

# --------------------------
# 0. Setup directories
# --------------------------
output_dir = "outputs"
os.makedirs(output_dir, exist_ok=True)
weights_dir = "weights"
os.makedirs(weights_dir, exist_ok=True)
print("‚úÖ Directories created/verified.")

# --------------------------
# 1. Load environment variables & Gemini client
# --------------------------
load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    raise ValueError("‚ùå GEMINI_API_KEY not found. Add it to your .env file")
print("‚úÖ Gemini API key loaded.")
client = genai.Client(api_key=api_key)

# --------------------------
# 2. Helper functions
# --------------------------
def encode_image(path):
    print(f"üîπ Encoding image: {path}")
    with open(path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def generate_gemini_image(prompt, img1_path, img2_path=None):
    print(f"üîπ Generating Gemini image with prompt: '{prompt}'")
    parts = [types.Part(text=prompt)]
    if img1_path:
        parts.append(types.Part(inline_data=types.Blob(mime_type="image/jpeg", data=encode_image(img1_path))))
    if img2_path:
        parts.append(types.Part(inline_data=types.Blob(mime_type="image/jpeg", data=encode_image(img2_path))))

    contents = [types.Content(parts=parts)]
    response = client.models.generate_content(
        model="gemini-2.0-flash-preview-image-generation",
        contents=contents,
        config=types.GenerateContentConfig(response_modalities=["TEXT", "IMAGE"]),
    )

    for candidate in response.candidates:
        for part in candidate.content.parts:
            if part.inline_data is not None:
                image = Image.open(BytesIO(part.inline_data.data))
                out_path = os.path.join(output_dir, "gen_img_using_gemini.png")
                image.save(out_path)
                print(f"‚úÖ Gemini image saved at {out_path}")
                return out_path
    raise RuntimeError("‚ùå No image was generated by Gemini!")

# --------------------------
# 3. Download weights if missing
# --------------------------
inswapper_path = os.path.join(weights_dir, "inswapper_128.onnx")
gfpgang_path = os.path.join(weights_dir, "GFPGANv1.4.pth")
realesrgan_path = os.path.join(weights_dir, "RealESRGAN_x4plus.pth")

if not os.path.exists(inswapper_path):
    print("‚¨áÔ∏è Downloading InsightFace inswapper weights...")
    gdown.download("https://drive.google.com/uc?id=1krOLgjW2tAPaqV-Bw4YALz0xT5zlb5HF", inswapper_path, quiet=False)
if not os.path.exists(gfpgang_path):
    print("‚¨áÔ∏è Downloading GFPGAN weights...")
    gdown.download("https://github.com/TencentARC/GFPGAN/releases/download/v1.3.4/GFPGANv1.4.pth", gfpgang_path, quiet=False)
if not os.path.exists(realesrgan_path):
    print("‚¨áÔ∏è Downloading Real-ESRGAN weights...")
    gdown.download("https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.0/RealESRGAN_x4plus.pth", realesrgan_path, quiet=False)
print("‚úÖ All model weights verified.")

# --------------------------
# 4. Initialize InsightFace (once)
# --------------------------
try:
    import tensorflow as tf
    ctx_id = 0  # GPU
    print("‚úÖ TensorFlow detected. Using GPU for InsightFace.")
except Exception:
    ctx_id = -1  # CPU
    print("‚ö†Ô∏è TensorFlow GPU not detected. Using CPU for InsightFace.")

app = FaceAnalysis(name='buffalo_l')
app.prepare(ctx_id=ctx_id, det_size=(640, 640))
print("‚úÖ InsightFace model initialized.")
swapper = get_model(inswapper_path, download=False, download_zip=False)
print("‚úÖ InsightFace swapper model loaded.")

def insightface_swap(source_path, target_path, output_path):
    print(f"üîπ Starting face swap: source={source_path}, target={target_path}")
    source_img_cv = cv2.cvtColor(cv2.imread(source_path), cv2.COLOR_BGR2RGB)
    target_img_cv = cv2.cvtColor(cv2.imread(target_path), cv2.COLOR_BGR2RGB)

    source_faces = app.get(source_img_cv)
    target_faces = app.get(target_img_cv)

    print(f"üîç Detected {len(source_faces)} face(s) in source, {len(target_faces)} face(s) in target.")

    if len(source_faces) == 0:
        return None, "No face detected in source image!"
    if len(target_faces) == 0:
        return None, "No face detected in target image!"

    result = swapper.get(target_img_cv, target_faces[0], source_faces[0], paste_back=True)
    cv2.imwrite(output_path, cv2.cvtColor(result, cv2.COLOR_RGB2BGR))
    print(f"‚úÖ Face swapped image saved at {output_path}")
    return output_path, None

# --------------------------
# 5. Full pipeline
# --------------------------
def process_images(prompt, img1_path, img2_path=None):
    print("üöÄ Starting full image processing pipeline...")

    # Step 1: Generate Gemini image (always saves as gen_img_using_gemini.png)
    product_img = generate_gemini_image(prompt, img1_path, img2_path)

    # Case 1: No person image ‚Üí return Gemini output only
    if not img2_path:
        print("‚ÑπÔ∏è No person image provided, returning gen_img_using_gemini.png")
        return os.path.join(output_dir, "gen_img_using_gemini.png")

    # Step 2: Face swap
    swapped_path = os.path.join(output_dir, "result_swap.jpg")
    swapped_result, error = insightface_swap(img2_path, product_img, swapped_path)

    if error:
        print(f"‚ùå Face swap skipped: {error}")
        return os.path.join(output_dir, "gen_img_using_gemini.png")  # fallback to Gemini output

    # Step 3: GFPGAN restoration
    print("üîπ Starting GFPGAN restoration...")
    img = cv2.imread(swapped_result)
    gfpganer = GFPGANer(model_path=gfpgang_path, upscale=1,
                        arch='clean', channel_multiplier=2,
                        bg_upsampler=None)
    _, _, restored = gfpganer.enhance(img, has_aligned=False,
                                      only_center_face=False, paste_back=True)
    restored_path = os.path.join(output_dir, "swapped_gfpgan.jpg")
    cv2.imwrite(restored_path, restored)
    print(f"‚úÖ GFPGAN restoration completed. Saved at {restored_path}")

    print("üéâ Image processing pipeline completed successfully!")
    return restored_path


